///! --- Day 2: Gift Shop ---

pub fn solve(input: &str) {
    println!("Part 1: {}", part1(input));
    println!("Part 2: {}", part2(input));
}

pub fn part1(input: &str) -> u64 {
    sum_repeated(input, false)
}

pub fn part2(input: &str) -> u64 {
    sum_repeated(input, true)
}

fn parse_ranges(input: &str) -> Vec<(u64, u64)> {
    input
        .split(',')
        .map(|range| {
            let parts: Vec<&str> = range.trim().split('-').collect();
            let start = parts[0].parse::<u64>().unwrap();
            let end = parts[1].parse::<u64>().unwrap();
            (start, end)
        })
        .collect()
}

/// Pattern configurations.
///
/// When checking all pattern types, some numbers can be generated multiple ways:
/// - 1111 can be: 1×1111 (pattern_length=1) OR 11×101 (pattern_length=2)
/// - 111111 can be: 1×111111 (length=1) OR 11×10101 (length=2) OR 111×1001 (length=3)
///
/// ## Mathematical Derivation
///
/// For each n_digits, we need to determine which pattern_lengths to include/subtract:
///
/// ### Pattern Coverage
/// If multiplier_A % multiplier_B == 0 (where A < B), then all numbers from
/// pattern_length=A are also generated by pattern_length=B.
///
/// ### Overlap Between Patterns
/// When multiple pattern_lengths are selected, they may generate overlapping numbers.
/// For example, with n_digits=6:
/// - (6, 2) multiplier=10101, (6, 3) multiplier=1001
/// - Both generate 111111: 11×10101 = 111×1001 = 111111
/// - lcm(10101, 1001) = 111111 (the overlap multiplier)
/// - This overlap corresponds to pattern_length=1
///
/// ### Examples for n_digits ≤ 10:
///
/// - **n=2**: divisors=[1] → include [1]
/// - **n=3**: divisors=[1] → include [1] (prime, no overlap possible)
/// - **n=4**: divisors=[1,2] → include [2], subtract [] (1 fully covered by 2)
/// - **n=5**: divisors=[1] → include [1] (prime, no overlap possible)
/// - **n=6**: divisors=[1,2,3] → include [2,3], subtract [1] (overlap between 2 and 3)
/// - **n=7**: divisors=[1] → include [1] (prime, no overlap possible)
/// - **n=8**: divisors=[1,2,4] → include [4], subtract [] (1,2 fully covered by 4)
/// - **n=9**: divisors=[1,3] → include [3], subtract [] (1 fully covered by 3)
/// - **n=10**: divisors=[1,2,5] → include [2,5], subtract [1] (overlap between 2 and 5)
const PATTERN_CONFIGS: &[(usize, &[usize], &[usize])] = &[
    // (n_digits, include_patterns, subtract_patterns)
    (2, &[1], &[]),
    (3, &[1], &[]),
    (4, &[2], &[]),
    (5, &[1], &[]),
    (6, &[2, 3], &[1]),
    (7, &[1], &[]),
    (8, &[4], &[]),
    (9, &[3], &[]),
    (10, &[2, 5], &[1]),
];

/// Calculate sum of repeated-digit numbers using arithmetic series formula.
///
/// A repeated-digit number is formed by repeating a base pattern multiple times.
/// For example, with n_digits=4 and pattern_length=2:
/// - Pattern 10 repeated: 10 * 101 = 1010
/// - Pattern 11 repeated: 11 * 101 = 1111
/// - Pattern 99 repeated: 99 * 101 = 9999
///
/// # The Multiplier Formula
///
/// The multiplier is: (10^n_digits - 1) / (10^pattern_length - 1)
///
/// To repeat a pattern, we need to shift it left and add it to itself.
/// For a 2-digit pattern XY creating a 4-digit number XYXY:
/// - XYXY = XY * 100 + XY = XY * (100 + 1) = XY * 101
///
/// For a 3-digit pattern XYZ creating a 6-digit number XYZXYZ:
/// - XYZXYZ = XYZ * 1000 + XYZ = XYZ * (1000 + 1) = XYZ * 1001
///
/// General pattern for repeating a pattern_length pattern n_digits/pattern_length times:
/// - multiplier = 10^pattern_length + 10^(2*pattern_length) + ... + 10^(n_digits - pattern_length) + 1
///
/// This is a geometric series with ratio r=10^pattern_length, which simplifies to:
/// - multiplier = (r^n - 1) / (r - 1) where n = n_digits/pattern_length
/// - multiplier = (10^n_digits - 1) / (10^pattern_length - 1)
///
/// # The Arithmetic Series
///
/// Instead of looping through each pattern and computing pattern * multiplier,
/// we use the fact that consecutive patterns form an arithmetic sequence.
///
/// For multiplier=11, patterns 1 to 5:
/// - Naive: 11*1 + 11*2 + 11*3 + 11*4 + 11*5 = 11 + 22 + 33 + 44 + 55 = 165
/// - Factor out: 11 * (1 + 2 + 3 + 4 + 5)
/// - Arithmetic series: 11 * ((1 + 5) * 5 / 2) = 11 * 15 = 165
///
/// General formula: multiplier * (min_pattern + max_pattern) * count / 2
fn sum_for_pattern(start: u64, end: u64, n_digits: usize, pattern_length: usize) -> u64 {
    let numerator = 10_u64.pow(n_digits as u32) - 1;
    let denominator = 10_u64.pow(pattern_length as u32) - 1;
    let multiplier = numerator / denominator;

    // Base pattern must have exactly pattern_length digits (no leading zeros).
    let min_valid_pattern = if pattern_length == 1 {
        1
    } else {
        10_u64.pow((pattern_length - 1) as u32)
    };
    let max_valid_pattern = 10_u64.pow(pattern_length as u32) - 1;

    let min_pattern = ((start + multiplier - 1) / multiplier).max(min_valid_pattern);
    let max_pattern = (end / multiplier).min(max_valid_pattern);

    if min_pattern > max_pattern {
        return 0;
    }

    let count = max_pattern - min_pattern + 1;
    let arithmetic_sum = (min_pattern + max_pattern) * count / 2;
    multiplier * arithmetic_sum
}

/// Sum all numbers with repeated digit patterns in the given ranges.
fn sum_repeated(input: &str, all_patterns: bool) -> u64 {
    let ranges = parse_ranges(input);
    let mut sum = 0u64;

    for (start, end) in ranges {
        let start_digits = ((start as f64).log10().floor() as usize) + 1;
        let end_digits = ((end as f64).log10().floor() as usize) + 1;

        // Start from n_digits=2 since single-digit numbers have no repeated patterns
        for n_digits in start_digits.max(2)..=end_digits {
            if all_patterns {
                // Part 2: use inclusion-exclusion with hardcoded patterns.

                // Look up pattern configuration.
                let (include_patterns, subtract_patterns) = PATTERN_CONFIGS
                    .iter()
                    .find(|(n, _, _)| *n == n_digits)
                    .map(|(_, inc, sub)| (*inc, *sub))
                    .unwrap_or_else(|| {
                        panic!(
                            "No pattern configuration found for n_digits={}. \
                             PATTERN_CONFIGS only supports n_digits up to {}.",
                            n_digits,
                            PATTERN_CONFIGS.last().map(|(n, _, _)| n).unwrap_or(&0)
                        )
                    });

                for &pattern_length in include_patterns {
                    sum += sum_for_pattern(start, end, n_digits, pattern_length);
                }

                for &pattern_length in subtract_patterns {
                    sum -= sum_for_pattern(start, end, n_digits, pattern_length);
                }
            } else {
                // Part 1: only half-repetitions.
                if n_digits % 2 == 0 {
                    let pattern_length = n_digits / 2;
                    sum += sum_for_pattern(start, end, n_digits, pattern_length);
                }
            }
        }
    }

    sum
}
